# Running and debugging the program

Run the program:

```
make run
```

Note how the program runs, shows output, but does not exit.

Add the following to the Makefile:

```
.PHONY: debug
debug:
	dlv debug
```

Run the debug make command.

Execute the `continue` command within the debug session. Note how there is no output.

Note that we must provide the list of URLs via stdin.

Note that we can stop the program with ctrl-c.

Use the restart command with a redirect:

```
restart < urls.txt
```

Then continue:

```
continue
```

Let program run for a bit then interrupt with ctrl-c.

Display goroutines:

```
goroutines
```

Ask the audience what is notable about the output.

Note that there is one goroutine waiting on chan recv.

Switch to that goroutine with the following:

```
goroutine 1
```

Look at the stack trace:

```
stack
```

Find the frame in user code, then execute the frame command like so:

```
frame <n> list
```

Note that the code is waiting on reading from a channel.

Note that we never closed that channel.

Apply the following diff to fix:

```
diff --git a/main.go b/main.go
index 58cc2ef..f1edd43 100644
--- a/main.go
+++ b/main.go
@@ -7,6 +7,7 @@ import (
 	"net/http"
 	"os"
 	"strings"
+	"sync"
 	"time"
 )

@@ -41,7 +42,9 @@ func doWork(id int, url string) int {
 	return number
 }

-func worker(id int, urls <-chan string, results chan<- int) {
+func worker(wg *sync.WaitGroup, id int, urls <-chan string, results chan<- int) {
+	wg.Add(1)
+	defer wg.Done()
 	for url := range urls {
 		results <- doWork(id, url)
 	}
@@ -50,6 +53,7 @@ func worker(id int, urls <-chan string, results chan<- int) {
 func main() {
 	var (
 		finalResult int
+		wg          sync.WaitGroup

 		workers = 5
 		urls    = make(chan string)
@@ -59,12 +63,14 @@ func main() {
 	scanner := bufio.NewScanner(os.Stdin)
 	start := time.Now()
 	for w := 1; w <= workers; w++ {
-		go worker(w, urls, results)
+		go worker(&wg, w, urls, results)
 	}
 	for scanner.Scan() {
 		urls <- scanner.Text()
 	}
 	close(urls)
+	wg.Wait()
+	close(results)
 	for num := range results {
 		finalResult += num
 	}
```

Run the program again and note it is still hanging.

Note we should attach debugger to program.

Add the following to the Makefile:

```
.PHONY: attach
attach:
	dlv attach $$(pgrep gc2023)
```

Attach to the process then execute the following in the debug session:

```
goroutines -with userloc main.go
```

Note we execute that because we only want to see the goroutines in the file we care about.

Note that all of them are blocked on channel send.

Switch to one of the goroutines:

```
goroutine <n>
```

Execute the same series of `bt` and then `frame <n> ls` to see what the code is doing.

Once we see it is blocked on sending to the results channel, run the following:

```
frame <n> print cap(results)
```

There we can see a capacity of 9 meaning this is an unbuffered channel.

The goroutines are blocked waiting to send meaning they never finish, meaning the `wg.Wait` hangs forever.

Fix this by adding a capacity of 5 in the source code.

Re run the program to see the bug is fixed.
