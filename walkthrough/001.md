# Running and debugging the program

Run the program:

```
make run
```

Note how the program runs, shows output, but does not exit.

Add the following to the Makefile:

```
.PHONY: debug
debug:
	dlv debug
```

Run the debug make command.

Execute the `continue` command within the debug session. Note how there is no output.

Note that we must provide the list of URLs via stdin.

Note that we can stop the program with ctrl-c.

Use the restart command with a redirect:

```
restart < urls.txt
```

Then continue:

```
continue
```

Let program run for a bit then interrupt with ctrl-c.

Display goroutines:

```
goroutines
```

Ask the audience what is notable about the output.

Note that there is one goroutine waiting on chan recv.

Switch to that goroutine with the following:

```
goroutine 1
```

Look at the stack trace:

```
stack
```

Find the frame in user code, then execute the frame command like so:

```
frame <n> list
```

Note that the code is waiting on reading from a channel.

Note that we never closed that channel.

Apply the following diff to fix:

```
diff --git a/main.go b/main.go
index 58cc2ef..f1edd43 100644
--- a/main.go
+++ b/main.go
@@ -7,6 +7,7 @@ import (
 	"net/http"
 	"os"
 	"strings"
+	"sync"
 	"time"
 )

@@ -41,7 +42,9 @@ func doWork(id int, url string) int {
 	return number
 }

-func worker(id int, urls <-chan string, results chan<- int) {
+func worker(wg *sync.WaitGroup, id int, urls <-chan string, results chan<- int) {
+	wg.Add(1)
+	defer wg.Done()
 	for url := range urls {
 		results <- doWork(id, url)
 	}
@@ -50,6 +53,7 @@ func worker(id int, urls <-chan string, results chan<- int) {
 func main() {
 	var (
 		finalResult int
+		wg          sync.WaitGroup

 		workers = 5
 		urls    = make(chan string)
@@ -59,12 +63,14 @@ func main() {
 	scanner := bufio.NewScanner(os.Stdin)
 	start := time.Now()
 	for w := 1; w <= workers; w++ {
-		go worker(w, urls, results)
+		go worker(&wg, w, urls, results)
 	}
 	for scanner.Scan() {
 		urls <- scanner.Text()
 	}
 	close(urls)
+	wg.Wait()
+	close(results)
 	for num := range results {
 		finalResult += num
 	}
```

Run the program again and note it is still hanging.
